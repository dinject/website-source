<html>
<head>
  <title>DInject Javalin controllers</title>
  <meta name="layout" content="_layout/parent_javalin.html"/>
  <meta name="bread2" content="Controller" href="/docs/javalin/controller"/>
<#assign controller="active">
</head>
<body>

<h2 id="controller">@Controller</h2>
<p>
  Create controllers with <code>@Path</code> and <code>@Controller</code>.  The <code>javalin-generator</code> will
  generate source code for mapping web routes to the controller method.
</p>
```java
@Controller
@Path("/foo")
class FooController {

  private final MyService myService;

  @Inject
  FooController(MyService myService) {
    this.myService = myService;
  }

  @Get("/:id")
  Foo getById(int id, String otherParam) {
    ...
  }

  @Post
  void save(Foo foo) {
    ...
  }

  @Get
  List<|Foo> getAll() {
    return myService.findAll();
  }
}

```
<p>
  The controllers can have dependencies injected. DInject will then add them to the context
  used for dependency injection.
</p>

<h2>Testing</h2>
<p>
  One of the big motivations of having these controllers is to help with testing.
</p>
<p>
  When testing the FooController:
</p>
<ul>
  <li>We can create FooController instances with mock/test doubles for it's dependencies (MyService)</li>
  <li>We can largely test the methods without any web context/request/response objects</li>
</ul>

<@next "@Get @Post etc" "annotations"/>

</body>
</html>
